#!/bin/env python
# -*- coding:utf-8 -*-

#
#  Autogenerated by Storm-Streaming Topology
#
#  DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from pyutil.program import metrics2 as metrics
from ss_lib.topology.util.bolt import CommonBolt
from ss_lib.topology.util.key_timer_batch_handler import KeyTimerBatchHandler

import gc, traceback, sys, time, os, threading, signal, logging, random, multiprocessing, ujson, json


class {{bolt_name}}(CommonBolt):
    def init(self, conf, dsignal):
        """ bolt init function, you can add your initialization below.
        Args:
            conf : A dict type, the key/value is from bolt args configuration in the topology.yaml
            dsignal : DSignal object, maybe you just need use dsignal.lock class member
        
        Returns:
            no return
        """
        self.conf = conf
        self.dsignal = dsignal

        try:
            self.handler = KeyTimerBatchHandler(conf, dsignal)
            self.key_index = self.conf.get("key_index",0)
            self.handler.start()
        except Exception as e:
            logging.exception(e)

    def on_signal(self, data):
        """ signal callback function
        Args:
            data : A dict type, eg:{'cmd' : 'stop'}

        Returns:
            no return

        """
        try:
            ts = time.time()
            if data.get("cmd") == "stop":
                self.handler.flush_interval = 0
                while 1:
                    with self.dsignal.lock:
                        if not len(self.handler.batch_buffer):
                            break
                        logging.info("wait pid[%d] flush cur buffer left : %d ...."%(os.getpid(), len(self.handler.batch_buffer)))
                    time.sleep(2)
                self.handler.stop()
                logging.info("pid[%d] handle stop signal end, handle time:%f"%(os.getpid(), time.time() - ts))
            elif data.get("cmd") == "reload":
                with self.dsignal.lock:
                    logging.info("start to reload the bolt, wait dsignal_lock time:%f"%(time.time() - ts))
                    self.handler.process_caller.restart()
                logging.info("handle reload signal end, handle time:%f"%(time.time() - ts))
            else :
                pass
        except Exception as e:
            logging.exception(e)

    def calc(self, tup, tup_type):
        """ add your logic here
        Args:
            tup : the stream data, a list type, eg:
              if the last bolt's output_fields:
                ["ut:uid", "gid", "gid:atype:atime:stream", "kt", "from_tup"], 
              the format of the tup is :
                ['12:1451376260', 3487133828, (3487302803, 202, 1408936076, '__feed__'), 1408936076, 0]
        Returns:
            res_list : A list type
              if the current bolt's output_fields is [c11,c21], you must return [[c11,c21]].
              if you want to emit more data at one time, you can return [[c11,c21],[c12, c22],[c13,c23], ...]

        """
        self.handler.collect(tup[self.key_index], tup)
        return []

{{bolt_name}}().run()

if __name__ == "__main__":
    pass
