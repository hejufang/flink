#!/bin/env python
# -*- coding:utf-8 -*-

#
#  Autogenerated by Storm-Streaming Topology
#
#  DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

from pyutil.program import metrics2 as metrics
from ss_lib.topology.util.common_bolt import CommonBolt

import gc, traceback, sys, time, os, threading, signal, logging, random, multiprocessing, ujson, json


class {{bolt_name}}(CommonBolt):
    def init(self, conf, dsignal):
        """ bolt init function, you can add your initialization below.
        Args:
            conf : A dict type, the key/value is from bolt args configuration in the topology.yaml
            dsignal : DSignal object, maybe you just need use dsignal.lock class member
        
        Returns:
            no return
        """
        self.conf = conf
        self.dsignal = dsignal

    def on_signal(self, data):
        """ signal callback function
        Args:
            data : A dict type, eg:{'cmd' : 'stop'}

        Returns:
            no return

        """
        pass
        

    def calc(self, tup):
        """ add your computational logic here
        Args:
            tup : the stream data, a list type, eg:
              if the last bolt's output_fields:
                ["ut:uid", "gid", "gid:atype:atime:stream", "kt", "from_tup"], 
              the format of the tup is :
                ['12:1451376260', 3487133828, (3487302803, 202, 1408936076, '__feed__'), 1408936076, 0]
        Returns:
            res_list : A list type
              if the current bolt's output_fields is [c11,c21], you must return [[c11,c21]].
              if you want to emit more data at one time, you can return [[c11,c21],[c12, c22],[c13,c23], ...]

        """
        {% if bolt_name == "helloworld" %}
        logging.info("helloworld-%s"%(str(tup)))
        {% else %}
        #======add your code here===========
        {% end %}
        return []


{{bolt_name}}().run()

if __name__ == "__main__":
    pass
