/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.flink.connectors.hive.read;

import org.apache.flink.util.FlinkRuntimeException;

import org.apache.hadoop.fs.FileStatus;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.PathFilter;
import org.apache.hadoop.mapred.FileInputFormat;
import org.apache.hadoop.mapred.FileSplit;
import org.apache.hadoop.mapred.InputSplit;
import org.apache.hadoop.mapred.InvalidInputException;
import org.apache.hadoop.mapred.JobConf;
import org.apache.hadoop.mapred.RecordReader;
import org.apache.hadoop.mapred.Reporter;
import org.apache.hadoop.mapreduce.security.TokenCache;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Return all file splits without location.
 */
public class FastFileInputFormat<K, V> extends FileInputFormat<K, V> {
	private static final Logger LOG = LoggerFactory.getLogger(FastFileInputFormat.class);

	private static final PathFilter hiddenFilter = new PathFilter() {
		@Override
		public boolean accept(Path p) {
			String name = p.getName();
			return !name.startsWith("_") && !name.startsWith(".");
		}
	};

	private static class MultiPathFilter implements PathFilter {
		private final List<PathFilter> filters;

		public MultiPathFilter(List<PathFilter> filters) {
			this.filters = filters;
		}

		public boolean accept(Path path) {
			for (PathFilter filter : filters) {
				if (!filter.accept(path)) {
					return false;
				}
			}
			return true;
		}
	}

	/**
	 * Get file input splits without file location information.
	 */
	@Override
	public InputSplit[] getSplits(JobConf job, int minSplits) throws IOException {
		long start = System.currentTimeMillis();
		Path[] dirs = getInputPaths(job);
		if (dirs.length == 0) {
			throw new IOException("No input paths specified in job");
		}

		// get tokens for all the required FileSystems..
		TokenCache.obtainTokensForNamenodes(job.getCredentials(), dirs, job);

		// Whether we need to recursive look into the directory structure
		boolean recursive = job.getBoolean(INPUT_DIR_RECURSIVE, false);

		// creates a MultiPathFilter with the hiddenFileFilter and the
		// user provided one (if any).
		List<PathFilter> filters = new ArrayList<PathFilter>();
		filters.add(hiddenFilter);
		PathFilter jobFilter = getInputPathFilter(job);
		if (jobFilter != null) {
			filters.add(jobFilter);
		}
		PathFilter inputFilter = new MultiPathFilter(filters);

		List<FileStatus> statusList = listStatus(job, dirs, inputFilter, recursive);
		if (statusList.size() < minSplits && statusList.size() != 0) {
			LOG.warn("Fallback to fileInputFormat get splits, this can't happen.");
			return super.getSplits(job, minSplits);
		}
		long cost = System.currentTimeMillis() - start;
		LOG.info("Total # of splits generated by getSplits: {}, TimeTaken: {}", statusList.size(), cost);
		return statusList.stream()
			.map(status -> makeSplit(status.getPath(), 0, status.getLen(), new String[0]))
			.toArray(FileSplit[]::new);
	}

	@Override
	public RecordReader<K, V> getRecordReader(InputSplit inputSplit, JobConf jobConf, Reporter reporter) throws IOException {
		throw new FlinkRuntimeException("Should never reach here");
	}

	private List<FileStatus> listStatus(
			JobConf job,
			Path[] dirs,
			PathFilter inputFilter,
			boolean recursive) throws IOException {
		List<FileStatus> result = new ArrayList<FileStatus>();
		List<IOException> errors = new ArrayList<IOException>();
		for (Path p: dirs) {
			FileSystem fs = p.getFileSystem(job);
			FileStatus[] matches = fs.globStatus(p, inputFilter);
			if (matches == null) {
				errors.add(new IOException("Input path does not exist: " + p));
			} else if (matches.length == 0) {
				errors.add(new IOException("Input Pattern " + p + " matches 0 files"));
			} else {
				for (FileStatus globStat: matches) {
					if (globStat.isDirectory()) {
						FileStatus[] fileStatuses =
							fs.listStatus(globStat.getPath());
						for (FileStatus stat: fileStatuses) {
							if (inputFilter.accept(stat.getPath())) {
								if (recursive && stat.isDirectory()) {
									addInputPathRecursively(result, fs, stat.getPath(),
										inputFilter);
								} else {
									result.add(stat);
								}
							}
						}
					} else {
						result.add(globStat);
					}
				}
			}
		}
		if (!errors.isEmpty()) {
			throw new InvalidInputException(errors);
		}
		return result;
	}
}
